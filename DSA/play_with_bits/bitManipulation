import org.w3c.dom.ls.LSOutput;

public class bitManipulation {

/* for unsigned number range is  0 to 2^n  - 1
* for signed number range is -2^(n-1) +1 to 2^(n-1) -1
* right shift   a>>b = a/2^b
* left shit     a<<b = a*2^b
* 1 s complement - not of a bit
* 2 s complement -  add +1 to 1 s complement
* to find the bit on ith position do (1<<i) & num !=0 then ith bit is set(1)
* odd number = (num&1)=0
* bits of a number =  shit number by i and & with 1
* set bit by doing or | with 1<<bit
* unset bit by doing and & with ~(1<<bit)
* toggle bit by doing xor ^  with 1<<bit*/

public static void main(String[] args) {
    oddEven(53) ;

    printBits(15);

    System.out.println(isBitSet(15,3));

    setBit(32,0);

    toggleBit(32,3);

    unsetBit(35,1);

    ispowerOf2(30);

    unsetRightMostBit(15);

    numberOfSetBits(15);

    clearLSB(53,4);

    clearMSB(53,4);

    clearMSBExclusive(53,4);

    char ch1 =charToUppercse('h');
    System.out.println(ch1);

    char ch2 =charToLowercse('H');
    System.out.println(ch2);

    swap(32,56);

    int arr[] = {2,4,4,2,4,6,7,7,4};
    uniqueElementInArray(arr);

    int arr2[] = {2,2,4,6,3,3};
    twoUniqueElementInArray(arr2);

}
public static void oddEven(int num) {
    if((num&1)==0){
        System.out.println(num+" is even");
    } else {
        System.out.println(num +" is odd");
    }
    System.out.println(".......................");

}

    public static void printBits(int num) {
    for(int i =7;i>=0;i--) {
        System.out.print((num>>i) &1);
    }
        System.out.println();

    }


    public static boolean isBitSet(int num, int bit) {
    int res = num & (1<< bit);

    return (res==0)?false:true;

    }

    public static void setBit(int num,int bit) {
    printBits(32);
     int res = num | (1<<bit);
        printBits(res);
        System.out.println(".......................");
    }

    public static void toggleBit(int num, int bit){
    printBits(32);
    int res = num^(1<<bit);
    printBits(res);
        System.out.println(".......................");
    }

    public static void unsetBit(int num,int bit) {
    printBits(35);
    int res = num & ~(1<<bit);
        printBits(res);
        System.out.println(".......................");
    }

    public static void ispowerOf2(int num){
    if((num & num-1)== 0) {
        System.out.println(num+" is power of 2");
    } else {
        System.out.println(num +" is not power of two");
    }
        System.out.println(".......................");

    }

    public static void unsetRightMostBit(int num){
    printBits(15);
    int res = (num & num-1);
        printBits(res);
        System.out.println(".......................");
    }


    public static void numberOfSetBits(int num){
    printBits(15);
       int count =0;
       while(num!=0) {
           num = (num& num-1);
           count++;
       }
        System.out.println(count);
        System.out.println(".......................");

    }

    /* for making all lsb unset after i th position,..
    suppose num is 110110 second 1 k bad se sab zero karnih
       & 110110
         100000 = x2
         how to make  x2 by inverse of i<<bit and this n&n-1
         therefore clearlsb(i) = num & ~((1<<(i+1))-1)


          clear all msb
          num & ((1<<i)-1)
          */
    public static void clearLSB(int num , int bit){
        printBits(35);
       int res = num & ~((1<<(bit+1))-1);
        printBits(res);
        System.out.println(".......................");
    }
    public static void clearMSB(int num, int bit){
        printBits(35);
        int res = num & ((1<<bit)-1);
        printBits(res);
        System.out.println(".......................");

    }
    public static void clearMSBExclusive(int num, int bit){
        printBits(35);
        int res = num & ((1<<bit+1)-1);
        printBits(res);
        System.out.println(".......................");

    }

    /* A = 65 = 1000001 5 th bit is unset
       a = 97 = 1100001 5 th bit is set

     */
    public static char charToUppercse(int num) {
        int res = num & ~(1 << 5); // or (num & '') gives same answer                unset 5th bit
           return (char)res;


    }

    public static char charToLowercse(int num) {
        int res = num | (1 << 5); //  or( num | '')    is also same as ascii value of space is 32
        //          set 5th bit
        return (char) res;
    }

           /*   num^0 = num
                num^num = 0
                associativity rule helds in xor

                    */
    public static void swap(int a, int b) {
        System.out.println(a+" "+b);
        a= a^b;
        b=a^b;
        a=a^b;
        System.out.println(a+" "+b);
        System.out.println(".............");

    }

    public static void uniqueElementInArray(int arr[]) {
           int res = 0;
        for(int i =0;i<arr.length;i++) {
             res = res^arr[i];
        }
        System.out.println(res);
        System.out.println(".............");

    }
    public static void twoUniqueElementInArray(int arr2[]) {
        int res = 0;
        for(int i =0;i<arr2.length;i++) {
            res = res^arr2[i];
        }
        int setbit = 0;
        int bit = 0;
        while(res!=0) {
            if( (res>> bit & 1)!= 0) {
                setbit = bit;
                break;
            }
            bit++;
        }
        int res1= 0;
        for(int i =0;i<arr2.length;i++) {
            if ((arr2[i] >> setbit & 1) != 0) {
                res1 = res1 ^ arr2[i];
            }
        }
            int num1= res^res1;
            int num2 = num1^ res;
            System.out.println(num1 +" "+ num2);

    }

}
